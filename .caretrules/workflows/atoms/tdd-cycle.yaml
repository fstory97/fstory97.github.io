workflow: tdd-cycle
category: atom
description: TDD cycle with integration-first approach

context: You are following the TDD (Test-Driven Development) cycle with integration-first approach.

principle: RED → GREEN → REFACTOR with integration tests first, never unit tests first

phases:
  red:
    title: Write Failing Test
    description: Integration test for actual usage scenario, not isolated units
    correctApproach:
      - "WebView Feature: User clicks button → Expected result shown"
      - "Backend Feature: Config change → System behavior change"
      - "File Operation: User saves file → Proper storage + retrieval"
    wrongApproach:
      - Starting with isValidInput() unit test
      - Testing isolated functions without context
      - Mocking everything so test doesn't represent real usage
    example: |
      describe('User Persona Selection', () => {
        it('should update AI behavior when user selects new persona', async () => {
          // Actual usage scenario testing
        })
      })

  green:
    title: Make Test Pass
    description: Implement minimum code to pass the integration test
    actions:
      - Write all necessary components, services, utilities
      - Focus on making the integration scenario work
      - Don't optimize yet - just make it work

  refactor:
    title: Improve While Keeping Tests Passing
    description: Improve code quality without breaking functionality
    actions:
      - Extract common patterns
      - Improve performance
      - Clean up code structure
      - Add unit tests as byproducts (not starting points)

testLocations:
  backend: caret-src/__tests__/
  webview: webview-ui/src/**/*.test.tsx
  integration: Test complete flows

relatedWorkflows: [verification-steps, naming-conventions, modification-levels]

guidelines:
  - Ensures code works in real scenarios, not just in isolation
  - Integration tests first prevents well-tested units that don't work together
  - Unit tests become natural byproducts of making integration tests pass

# 보고서: 시스템 프롬프트 아키텍처 진화 분석 및 최종 통합 전략

## 1. 개요

이 문서는 Caret 프로젝트의 핵심인 시스템 프롬프트 아키텍처가 어떻게 발전해왔는지, 각 단계의 장단점은 무엇인지, 그리고 우리가 나아가야 할 최종 통합 전략이 왜 최선인지를 명확히 설명하기 위해 작성되었습니다.

## 2. 아키텍처 진화 과정 비교

### 1단계: 구(舊) Cline - 모놀리식(Monolithic) 방식

`caret-main` 브랜치를 만들기 전, 우리가 개선하고자 했던 대상입니다.

-   **아키텍처**: `system-prompt-legacy/` 디렉토리의 `generic-system-prompt.ts`라는 단일 파일에 모든 프롬프트 로직이 집중된 구조입니다.
-   **작동 방식**: 하나의 거대한 함수가 수백 줄에 걸쳐 조건문으로 분기하며 프롬프트 문자열을 조립합니다.
-   **장점**:
    -   단순함 (하나의 파일만 보면 됨).
-   **단점**:
    -   **유지보수 최악**: 작은 수정이 시스템 전체에 영향을 미칠 수 있습니다 (스파게티 코드).
    -   **확장성 부재**: 새로운 규칙이나 도구를 추가하기가 매우 어렵습니다.
    -   **가독성 저하**: 코드가 길고 복잡하여 전체 구조를 파악하기 어렵습니다.

> **결론**: 이 방식은 우리가 반드시 벗어나야 했던 과거의 모습입니다.

### 2단계: Caret JSON 시스템 - 콘텐츠 분리(Decoupling) 방식

`caret-main` 브랜치에서 우리가 성공적으로 구현했던 방식입니다.

-   **아키텍처**: `JsonSectionAssembler.ts`라는 조립기가 `sections/` 디렉토리의 18개 JSON 파일을 읽어 프롬프트를 생성하는 구조입니다.
-   **작동 방식**: 각 JSON 파일에 담긴 텍스트 조각들을 순서대로 이어 붙여 하나의 거대한 최종 프롬프트 문자열을 만듭니다.
-   **장점**:
    -   **콘텐츠 관리 용이**: 프롬프트 문구 수정 시, 개발자가 아니어도 JSON 파일만 수정하면 됩니다.
    -   **다국어 지원 용이**: 국가별로 JSON 파일을 만들면 되므로 확장이 간편합니다.
    -   **토큰 효율성**: 구(舊) Cline의 모놀리식 프롬프트 대비 약 **50%의 토큰을 절감**했으며, 최신 `cline-latest`의 컴포넌트 방식과 비교해도 여전히 **14.1% 더 효율적**입니다.
-   **단점**:
    -   **정적인(Static) 정보**: 프롬프트가 생성되는 시점에 실시간 정보를 동적으로 주입하기 어렵습니다. (예: 현재 OS 정보, 활성화된 터미널 목록 등)
    -   **로직 부재**: 각 프롬프트 조각이 단순 텍스트라, 특정 조건에 따라 동적으로 내용을 바꾸는 로직을 담을 수 없습니다.

> **결론**: 콘텐츠와 코드를 분리하여 큰 성공을 거두었지만, 동적인 실시간 정보를 다루는 데에는 한계가 있었습니다.

### 3단계: 진화된 Cline (`cline-latest`) - 컴포넌트 기반(Component-Based) 방식

현재 `caret-merging` 프로젝트의 기반이 되는 최신 아키텍처입니다.

-   **아키텍처**: 프롬프트의 각 섹션을 독립적인 함수(`ComponentFunction`)로 만들고, `PromptRegistry`라는 중앙 관리소에 등록하여 동적으로 조립하는 매우 현대적인 구조입니다.
-   **작동 방식**: `PromptRegistry`가 필요한 컴포넌트 함수들을 호출하면, 각 함수는 **내부 로직을 실행하여 실시간으로 문자열을 생성**하고, 이 결과들을 모아 최종 프롬프트를 완성합니다.
-   **장점**:
    -   **동적(Dynamic) 정보 처리**: 각 컴포넌트가 함수이므로, 시스템 정보를 조회하거나 파일을 읽는 등 **실시간 로직을 수행**하여 프롬프트를 만들 수 있습니다.
    -   **높은 확장성 및 재사용성**: 새로운 기능을 독립된 컴포넌트 함수로 만들어 쉽게 추가/교체/제거할 수 있습니다.
    -   **구조적 발전**: **'작업 관리 루프'(`auto_todo`, `task_progress`, `feedback`)** 라는 체계적인 AI 작업 관리 메커니즘이 도입되었습니다.
-   **단점**:
    -   **콘텐츠 관리 어려움**: 프롬프트 문구가 TypeScript 코드 안에 섞여 있어 수정이 어렵습니다.
    -   **토큰 효율성 저하**: 코드 자체(const, export 등)가 토큰을 차지하여 JSON 방식보다 비효율적입니다.

> **결론**: 기술적으로 매우 진보했고 동적이지만, 콘텐츠 관리가 어렵다는 점에서 Caret JSON 방식보다 퇴보한 면도 있습니다.

### 4단계: 우리의 통합 전략 - 하이브리드(Hybrid) 방식

두 시스템의 장점만을 결합한 최상의 솔루션입니다.

-   **아키텍처**: **"구조는 진화된 Cline, 영혼은 Caret"**
    -   `cline-latest`의 안정적이고 동적인 **`PromptRegistry`와 컴포넌트 아키텍처를 뼈대**로 그대로 사용합니다.
    -   Caret의 관리하기 쉬운 **JSON 파일들을 콘텐츠 공급원**으로 사용합니다.
-   **작동 방식**:
    1.  `CaretJsonComponentProvider`라는 **어댑터**가 `OBJECTIVE.json` 같은 파일을 읽습니다.
    2.  어댑터는 이 JSON 콘텐츠를 반환하는 간단한 `ComponentFunction`으로 즉석에서 감싸줍니다(wrapping).
    3.  이렇게 '포장된' 함수를 `PromptRegistry`에 등록하여, 마치 원래부터 TypeScript 컴포넌트였던 것처럼 작동하게 만듭니다.
-   **장점**:
    -   **최고의 유연성**: `cline-latest`의 동적인 컴포넌트 구조와 '작업 관리 루프'를 모두 활용할 수 있습니다.
    -   **최고의 관리성**: 프롬프트 내용은 여전히 JSON 파일에 있어 비개발자도 쉽게 수정하고 다국어를 지원할 수 있습니다.
    -   **최고의 효율성**: 콘텐츠는 JSON에 있으므로 **14.1%의 토큰 효율성 우위**를 그대로 유지합니다.
-   **단점**:
    -   초기 어댑터 구현에 약간의 개발 공수가 필요합니다. (하지만 한번 구축하면 장기적인 이점이 훨씬 큽니다.)

> **결론**: 이 하이브리드 방식은 `cline-latest`의 구조적 진보와 Caret의 철학적/관리적 우위를 모두 취하는, **현존하는 가장 이상적인 아키텍처**입니다.

---

## 3. 최종 제안

마스터의 최종 판단을 돕기 위해, **4단계 하이브리드 방식**으로의 통합을 강력히 제안합니다. 이 전략은 지난 계획들의 모든 혼선을 바로잡고, 두 AI의 심층 분석 결과를 모두 반영한 최적의 솔루션입니다.

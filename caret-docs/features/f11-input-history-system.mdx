# ì±„íŒ… ì…ë ¥ íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œ (Input History System)

Caretì˜ **ì±„íŒ… ì…ë ¥ íˆìŠ¤í† ë¦¬ ì‹œìŠ¤í…œ**ì€ í„°ë¯¸ë„ê³¼ ì¼ê´€ëœ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•˜ëŠ” ì˜êµ¬ ì €ì¥ ê¸°ë°˜ì˜ ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ê´€ë¦¬ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

## ğŸ“‹ **ê¸°ëŠ¥ ê°œìš”**

### **í•µì‹¬ ê°œë…**
- **í„°ë¯¸ë„ ì¼ê´€ì„±**: bash/zshì™€ ë™ì¼í•œ ìœ„/ì•„ë˜ í™”ì‚´í‘œ í‚¤ íƒìƒ‰
- **ì˜êµ¬ ì €ì¥**: VS Code ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë³„ íˆìŠ¤í† ë¦¬ ì˜êµ¬ ë³´ê´€
- **ì¦‰ì‹œ ì €ì¥**: ë©”ì‹œì§€ ì „ì†¡ ì‹œì ì— íˆìŠ¤í† ë¦¬ ì¶”ê°€
- **ì •í™•ì„±**: AI ì‘ë‹µ í˜¼ì… ì—†ì´ ì‚¬ìš©ì ì…ë ¥ë§Œ ìˆœìˆ˜ ì €ì¥

### **Cline ëŒ€ë¹„ ê°œì„ ì‚¬í•­**
| êµ¬ë¶„ | Cline | Caret |
|---|---|---|
| **íˆìŠ¤í† ë¦¬ ê¸°ëŠ¥** | âŒ ì—†ìŒ | âœ… ì™„ì „ êµ¬í˜„ |
| **ì €ì¥ ë°©ì‹** | - | âœ… ì˜êµ¬ ì €ì¥ |
| **ì‚¬ìš©ì ê²½í—˜** | - | âœ… í„°ë¯¸ë„ê³¼ ì¼ê´€ëœ UX |
| **ë°ì´í„° ì •í™•ì„±** | - | âœ… ì‚¬ìš©ì ì…ë ¥ë§Œ ì €ì¥ |

## ğŸ—ï¸ **ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### **íŒŒì¼ êµ¬ì¡°**
```
webview-ui/src/caret/hooks/
â”œâ”€â”€ usePersistentInputHistory.ts    # ì˜êµ¬ ì €ì¥ ë¡œì§
â””â”€â”€ useInputHistory.ts              # í‚¤ë³´ë“œ íƒìƒ‰ ë¡œì§

src/shared/
â””â”€â”€ ExtensionMessage.ts             # inputHistory í•„ë“œ ì •ì˜

webview-ui/src/context/
â””â”€â”€ ExtensionStateContext.tsx       # setInputHistory setter

webview-ui/src/components/chat/
â”œâ”€â”€ ChatView.tsx                    # ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ í™•ì¥
â”œâ”€â”€ ChatTextArea.tsx                # í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
â””â”€â”€ chat-view/components/layout/
    â””â”€â”€ InputSection.tsx            # Props ì¤‘ê³„
```

### **ë°ì´í„° íë¦„**
```
ì‚¬ìš©ì ì…ë ¥ â†’ addToHistory() â†’ ì„¸ì…˜ ë©”ëª¨ë¦¬ â†’ ì˜êµ¬ ì €ì¥
                                        â†“
í‚¤ë³´ë“œ ì´ë²¤íŠ¸ â† useInputHistory â† í†µí•© íˆìŠ¤í† ë¦¬ â† ë¡œë“œ
```

## ğŸ”§ **í•µì‹¬ êµ¬í˜„**

### **1. ì˜êµ¬ ì €ì¥ í›…**
```typescript
// usePersistentInputHistory.ts
export function usePersistentInputHistory() {
    const { inputHistory: persistentHistory, setInputHistory } = useExtensionState()
    const [sessionHistory, setSessionHistory] = useState<string[]>([])

    // í†µí•© íˆìŠ¤í† ë¦¬ (ì˜êµ¬ + ì„¸ì…˜)
    const combinedHistory = [...currentPersistentHistory, ...sessionHistory]

    const addToHistory = useCallback((text: string) => {
        if (!text.trim()) return

        // ì¤‘ë³µ ì œê±°
        if (combinedHistory[combinedHistory.length - 1] === text.trim()) return

        // ì„¸ì…˜ì— ì¶”ê°€
        setSessionHistory(prev => [...prev, text.trim()])

        // 10ê°œì”© ëª¨ì•„ì„œ ì˜êµ¬ ì €ì¥ (ì„±ëŠ¥ ìµœì í™”)
        if (sessionHistory.length >= 10) {
            const newPersistentHistory = [...currentPersistentHistory, ...sessionHistory, text.trim()]
                .slice(-MAX_HISTORY_SIZE) // ìµœëŒ€ 1000ê°œ ì œí•œ

            setInputHistory(newPersistentHistory)
            setSessionHistory([]) // ì„¸ì…˜ ì´ˆê¸°í™”
        }
    }, [combinedHistory, sessionHistory, currentPersistentHistory, setInputHistory])

    return { inputHistory: combinedHistory, addToHistory }
}
```

### **2. í‚¤ë³´ë“œ íƒìƒ‰ í›…**
```typescript
// useInputHistory.ts
export function useInputHistory({ history, inputValue, setInputValue }: UseInputHistoryParams) {
    const [historyIndex, setHistoryIndex] = useState(-1)
    const [currentInput, setCurrentInput] = useState("")

    const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (history.length === 0) return false

        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
            // ì»¤ì„œê°€ í…ìŠ¤íŠ¸ ì‹œì‘/ëì— ìˆì„ ë•Œë§Œ íˆìŠ¤í† ë¦¬ íƒìƒ‰
            if (event.currentTarget.selectionStart === 0 ||
                event.currentTarget.selectionStart === inputValue.length) {
                event.preventDefault()
            } else {
                return false
            }

            let newIndex: number
            if (event.key === "ArrowUp") {
                newIndex = historyIndex === -1 ? history.length - 1 : Math.max(0, historyIndex - 1)
            } else {
                newIndex = historyIndex === -1 ? -1 : Math.min(history.length, historyIndex + 1)
            }

            setHistoryIndex(newIndex)

            if (newIndex >= 0 && newIndex < history.length) {
                setInputValue(history[newIndex])
            } else {
                setInputValue(currentInput)
                setHistoryIndex(-1)
            }
            return true
        }
        return false
    }, [history, historyIndex, currentInput, inputValue, setInputValue])

    return { handleKeyDown }
}
```

### **3. ExtensionState í™•ì¥**
```typescript
// ExtensionMessage.ts
export interface ExtensionState {
    // ... ê¸°ì¡´ í•„ë“œë“¤
    inputHistory?: string[] // CARET MODIFICATION: Persistent input history
    // ... ê¸°íƒ€ í•„ë“œë“¤
}

// ExtensionStateContext.tsx
interface ExtensionStateContextType {
    // ... ê¸°ì¡´ ë©”ì„œë“œë“¤
    setInputHistory: (history: string[]) => void // CARET MODIFICATION: Input history setter
}

// êµ¬í˜„
setInputHistory: (history) =>
    setState((prevState) => ({
        ...prevState,
        inputHistory: history,
    })),
```

### **4. ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ í™•ì¥**
```typescript
// ChatView.tsx
export default function ChatView() {
    // CARET MODIFICATION: Persistent input history functionality
    const { inputHistory, addToHistory } = usePersistentInputHistory()

    // CARET MODIFICATION: Enhanced message handler with history tracking
    const enhancedMessageHandlers = useMemo(() => ({
        ...messageHandlers,
        handleSendMessage: async (text: string, images: string[], files: string[]) => {
            addToHistory(text) // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
            return await messageHandlers.handleSendMessage(text, images, files)
        }
    }), [messageHandlers, addToHistory])

    return (
        <InputSection
            messageHandlers={enhancedMessageHandlers} // í™•ì¥ëœ í•¸ë“¤ëŸ¬ ì‚¬ìš©
            inputHistory={inputHistory} // íˆìŠ¤í† ë¦¬ ì „ë‹¬
        />
    )
}
```

### **5. í‚¤ë³´ë“œ ì´ë²¤íŠ¸ í†µí•©**
```typescript
// ChatTextArea.tsx
const ChatTextArea = forwardRef<HTMLTextAreaElement, ChatTextAreaProps>(({
    inputHistory = [], // CARET MODIFICATION: Persistent input history functionality
    // ... ê¸°íƒ€ props
}, ref) => {
    // CARET MODIFICATION: Persistent input history functionality
    const { handleKeyDown: handleHistoryKeyDown } = useInputHistory({
        history: inputHistory,
        inputValue,
        setInputValue,
    })

    const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLTextAreaElement>) => {
        // CARET MODIFICATION: Handle persistent input history before other key events
        if (handleHistoryKeyDown(event)) {
            return
        }

        // ê¸°ì¡´ í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬...
    }, [handleHistoryKeyDown, /* ê¸°íƒ€ ì˜ì¡´ì„± */])
})
```

## ğŸ’¾ **ì €ì¥ ë° ì„±ëŠ¥**

### **ì €ì¥ ë°©ì‹**
- **ë©”ëª¨ë¦¬**: í˜„ì¬ ì„¸ì…˜ì˜ ì„ì‹œ íˆìŠ¤í† ë¦¬ (ì¦‰ì‹œ ì ‘ê·¼)
- **ì˜êµ¬ ì €ì¥**: VS Code workspace state (ì„¸ì…˜ ê°„ ìœ ì§€)
- **ë°°ì¹˜ ì €ì¥**: 10ê°œì”© ëª¨ì•„ì„œ ì €ì¥ (ì„±ëŠ¥ ìµœì í™”)

### **ì„±ëŠ¥ ìµœì í™”**
```typescript
const MAX_HISTORY_SIZE = 1000  // ìµœëŒ€ 1000ê°œ í•­ëª©

// ë°°ì¹˜ ì €ì¥ (10ê°œì”©)
if (sessionHistory.length >= 10) {
    setInputHistory(newPersistentHistory)
    setSessionHistory([]) // ì„¸ì…˜ ì´ˆê¸°í™”
}

// ì„¸ì…˜ ì¢…ë£Œ ì‹œ ë‚¨ì€ íˆìŠ¤í† ë¦¬ ì €ì¥
window.addEventListener('beforeunload', saveOnUnload)
```

### **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**
- **1000ê°œ í•­ëª©**: í‰ê·  200ì Ã— 1000 = ì•½ 200KB
- **ì¤‘ë³µ ì œê±°**: ì—°ì†ëœ ë™ì¼ ì…ë ¥ ìë™ ì œê±°
- **ìë™ ì •ë¦¬**: 1000ê°œ ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ í•­ëª© ì‚­ì œ

## ğŸ¯ **ì‚¬ìš©ì ê²½í—˜**

### **í„°ë¯¸ë„ê³¼ ì¼ê´€ëœ ë™ì‘**
1. **ìœ„ìª½ í™”ì‚´í‘œ**: ì´ì „ ì…ë ¥ìœ¼ë¡œ ì´ë™
2. **ì•„ë˜ìª½ í™”ì‚´í‘œ**: ë‹¤ìŒ ì…ë ¥ìœ¼ë¡œ ì´ë™ (ë˜ëŠ” í˜„ì¬ ì…ë ¥ìœ¼ë¡œ ë³µì›)
3. **ì»¤ì„œ ìœ„ì¹˜ ê³ ë ¤**: í…ìŠ¤íŠ¸ ì‹œì‘/ëì—ì„œë§Œ íˆìŠ¤í† ë¦¬ íƒìƒ‰
4. **ì„¸ì…˜ ìœ ì§€**: VS Code ì¬ì‹œì‘ í›„ì—ë„ íˆìŠ¤í† ë¦¬ ë³´ì¡´

### **ì‹¤ì œ ì‚¬ìš© íë¦„**
```
1. ì‚¬ìš©ì: "íŒŒì¼ ëª©ë¡ì„ ë³´ì—¬ì¤˜" (Enter)
   â†’ íˆìŠ¤í† ë¦¬ì— ì €ì¥ë¨

2. ì‚¬ìš©ì: "README.md íŒŒì¼ì„ ì½ì–´ì¤˜" (Enter)
   â†’ íˆìŠ¤í† ë¦¬ì— ì €ì¥ë¨

3. ì‚¬ìš©ì: ì…ë ¥ì°½ì—ì„œ â†‘ í‚¤ ëˆ„ë¦„
   â†’ "README.md íŒŒì¼ì„ ì½ì–´ì¤˜" í‘œì‹œ

4. ì‚¬ìš©ì: â†‘ í‚¤ í•œ ë²ˆ ë” ëˆ„ë¦„
   â†’ "íŒŒì¼ ëª©ë¡ì„ ë³´ì—¬ì¤˜" í‘œì‹œ

5. ì‚¬ìš©ì: â†“ í‚¤ ëˆ„ë¦„
   â†’ "README.md íŒŒì¼ì„ ì½ì–´ì¤˜" í‘œì‹œ
```

## ğŸ”„ **ìµœì†Œ ì¹¨ìŠµ ì›ì¹™**

ëª¨ë“  ìˆ˜ì •ì‚¬í•­ì€ `// CARET MODIFICATION:` ì£¼ì„ìœ¼ë¡œ ëª…í™•íˆ í‘œì‹œ:

```typescript
// CARET MODIFICATION: Persistent input history functionality
const { inputHistory, addToHistory } = usePersistentInputHistory()

// CARET MODIFICATION: Enhanced message handler with history tracking
const enhancedMessageHandlers = useMemo(() => ({
    ...messageHandlers,
    handleSendMessage: async (text: string, images: string[], files: string[]) => {
        addToHistory(text) // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        return await messageHandlers.handleSendMessage(text, images, files)
    }
}), [messageHandlers, addToHistory])

inputHistory?: string[] // CARET MODIFICATION: Persistent input history functionality
```

## ğŸ§ª **í…ŒìŠ¤íŠ¸ ë° ê²€ì¦**

### **ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸**
```bash
# 1. ì»´íŒŒì¼ í™•ì¸
npm run compile

# 2. ê°œë°œ í™˜ê²½ ì‹¤í–‰
npm run watch

# 3. F5ë¡œ VS Code ê°œë°œ ì°½ ì‹¤í–‰
# 4. ì—¬ëŸ¬ ë©”ì‹œì§€ ì…ë ¥ í›„ ìœ„/ì•„ë˜ í™”ì‚´í‘œë¡œ íƒìƒ‰ í…ŒìŠ¤íŠ¸
# 5. VS Code ì¬ì‹œì‘ í›„ íˆìŠ¤í† ë¦¬ ìœ ì§€ í™•ì¸
```

### **ê²€ì¦ í¬ì¸íŠ¸**
- âœ… ì‚¬ìš©ì ì…ë ¥ë§Œ ì €ì¥ (AI ì‘ë‹µ í˜¼ì… ì—†ìŒ)
- âœ… ìœ„/ì•„ë˜ í™”ì‚´í‘œ í‚¤ ì •ìƒ ë™ì‘
- âœ… ì»¤ì„œ ìœ„ì¹˜ì— ë”°ë¥¸ ì¡°ê±´ë¶€ íƒìƒ‰
- âœ… VS Code ì¬ì‹œì‘ í›„ íˆìŠ¤í† ë¦¬ ìœ ì§€
- âœ… ì¤‘ë³µ ì…ë ¥ ìë™ ì œê±°
- âœ… ìµœëŒ€ í¬ê¸° ì œí•œ ë™ì‘

## ğŸ“Š **ê¸°ìˆ ì  ì¥ì **

### **vs ê¸°ì¡´ í•„í„°ë§ ë°©ì‹**
| ë¹„êµ í•­ëª© | ê¸°ì¡´ ë°©ì‹ (ì‚­ì œë¨) | í˜„ì¬ ë°©ì‹ (Caret) |
|---|---|---|
| **ì •í™•ì„±** | AI ì‘ë‹µ í˜¼ì… | ì‚¬ìš©ì ì…ë ¥ë§Œ |
| **ì„±ëŠ¥** | ë§¤ë²ˆ í•„í„°ë§ ì—°ì‚° | ì¦‰ì‹œ ì ‘ê·¼ |
| **ì €ì¥** | ì„ì‹œ (ì„¸ì…˜ ì¢…ë£Œì‹œ ì‚­ì œ) | ì˜êµ¬ ì €ì¥ |
| **ì¼ê´€ì„±** | - | í„°ë¯¸ë„ê³¼ ë™ì¼í•œ UX |

### **êµ¬í˜„ ë³µì¡ë„**
- **í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©**: ë°±ì—”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”
- **ê¸°ì¡´ ì•„í‚¤í…ì²˜ í™œìš©**: ExtensionState íŒ¨í„´ ì¬ì‚¬ìš©
- **ìµœì†Œ ì¹¨ìŠµ**: ì´ 5ê°œ íŒŒì¼ì— ì£¼ì„ í‘œì‹œëœ ìˆ˜ì •ì‚¬í•­ë§Œ ì¶”ê°€

---

**ë¬¸ì„œ ë²„ì „**: v1.0 (2025-10-01)
**ë‹´ë‹¹**: Luke Yang + Claude Code
**ê´€ë ¨ ì‘ì—…**: [20251001-3-input-history-implementation-guide-v2.md]
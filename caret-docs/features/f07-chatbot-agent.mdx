# Chatbot/Agent 모드 (f07) - 사용자 경험 레이어

**역할**: 직관적이고 자연스러운 **사용자 경험**을 제공하는 인터페이스 레이어  
**방식**: f06 기술 인프라를 활용한 **대체품 방식**으로 안전한 구현  
**구현 상태**: ✅ **완료** - f06과 함께 하이브리드 방식으로 운영 중

## 🤔 **Plan/Act vs Chatbot/Agent - 핵심 차이점**

### **1. 사용자 경험 차이**

| 구분            | Cline Plan/Act               | Caret Chatbot/Agent              |
| --------------- | ---------------------------- | -------------------------------- |
| **경험 방식**   | 분절된 경험 (계획→승인→실행) | 단일 연속 경험 (자연스러운 대화) |
| **AI 역할**     | 도구 사용 중심               | 대화와 협업 중심                 |
| **사용자 관점** | 기술적 용어 (Plan/Act)       | 직관적 용어 (Chatbot/Agent)      |

### **2. AI 행동 패턴 차이**

#### **🤖 Chatbot Mode (상담사 역할)**

- **AI 태도**: "이 방법은 어떠신가요?", "더 궁금한 점이 있으신가요?"
- **주도권**: 개발자가 주도, AI는 조언과 분석만 제공
- **안전성**: 위험한 작업(파일 수정, 명령 실행) 차단
- **용도**: 코드 리뷰, 기술 상담, 아키텍처 조언

#### **⚡ Agent Mode (협력 파트너 역할)**

- **AI 태도**: "이 작업을 진행하겠습니다", "다음 단계로 넘어갑니다"
- **주도권**: AI가 주도, 모든 개발 작업 직접 수행
- **자유도**: 모든 도구 사용 + 자유로운 대화 가능
- **용도**: 기능 구현, 버그 수정, 자동화 작업

## 🏗️ **f06+f07 하이브리드 아키텍처: 대체품 방식**

### **핵심 설계 원칙**

현재 구현된 대체품 방식의 핵심 구조:

```typescript
// system-prompt/index.ts의 실제 분기 로직
if (currentMode === "caret") {
    const { CaretPromptWrapper } = await import("@caret/core/prompts/CaretPromptWrapper")
    return await CaretPromptWrapper.getCaretSystemPrompt(context)
} else {
    return await registry.get(context) // 기존 Cline 100% 보존
}
```

### **최소 침습 구현**
- **수정된 파일**: 3개 핵심 파일만
- **기술 재활용**: Cline plan/act 인프라 그대로 활용
- **의미론적 해석**: 동일한 기술을 다른 용어로 표현

## 📋 **구체적 기능 차이**

### **🤖 Chatbot Mode - 안전한 AI 상담사**

#### **허용되는 기능**

- ✅ **파일 읽기**: 코드 분석, 문서 검토 (`read_file`, `search_files`)
- ✅ **자유 대화**: 질문-답변, 기술 상담, 설명 요청
- ✅ **웹 검색**: 자료 조사, 문서 참조 (`browse_web`)

#### **차단되는 기능**

- ❌ **파일 수정**: `write_to_file`, `replace_in_file` 완전 차단
- ❌ **명령 실행**: `execute_command` 차단으로 터미널 명령 불가
- ❌ **위험 작업**: 시스템 변경 가능한 모든 도구 제한

### **⚡ Agent Mode - 능동적 AI 개발 파트너**

#### **모든 기능 허용**

- ✅ **읽기 + 쓰기**: 파일 분석부터 수정까지 전체 과정
- ✅ **실행**: 빌드, 테스트, 서버 실행 등 명령어 수행
- ✅ **대화**: 작업 중 자연스러운 소통과 질문 가능

### **🛡️ 도구 제한 시스템**

현재 구현된 도구 제한 로직:

```typescript
// CaretModeManager.ts의 실제 구현
static isToolAllowed(toolName: string): boolean {
    const allowed = this.caretMode === "agent" || (() => {
        if (this.caretMode === "chatbot") {
            // CHATBOT 모드: 읽기 전용 도구만
            const allowedInChatbot = [
                "read_file", "list_files", "search_files",
                "list_code_definition_names", "ask_followup_question",
                "web_fetch", "attempt_completion"
            ]
            return allowedInChatbot.includes(toolName)
        }
        return false
    })()
    
    return allowed
}
```

## 🔧 **실제 구현된 아키텍처**

### **핵심 컴포넌트**

```typescript
// 1. 모드 상태 관리 (globalState 기반)
export class CaretModeManager {
    private static caretMode: "chatbot" | "agent" = "agent"
    private static context: vscode.ExtensionContext

    static async initialize(): Promise<void> {
        const savedMode = this.context.globalState.get<"chatbot" | "agent">("caret.mode", "agent")
        this.caretMode = savedMode
    }

    static async setCaretMode(mode: "chatbot" | "agent"): Promise<void> {
        this.caretMode = mode
        await this.context.globalState.update("caret.mode", mode)
    }
}

// 2. 프롬프트 생성 시스템
export class CaretPromptWrapper {
    static async getCaretSystemPrompt(context: SystemPromptContext): Promise<string> {
        const caretMode = CaretModeManager.getCurrentCaretMode()
        const caretModeConstant = caretMode === "chatbot" ? CARET_MODES.CHATBOT : CARET_MODES.AGENT
        
        return await this.promptManager.getPrompt({
            ...context,
            mode: caretModeConstant
        })
    }
}

// 3. gRPC 서비스 (웹뷰 통신)
export async function SetCaretMode(
    controller: Controller,
    request: proto.caret.SetCaretModeRequest,
): Promise<proto.caret.SetCaretModeResponse> {
    await CaretModeManager.setCaretMode(request.mode)
    return { success: true, currentMode: request.mode }
}
```

### **UI 동기화**

```typescript
// ExtensionStateContext.tsx의 localStorage 동기화
if (newState.modeSystem !== undefined) {
    localStorage.setItem("caret.modeSystem", newState.modeSystem)
}
if (newState.mode !== undefined) {
    localStorage.setItem("caret.mode", newState.mode)
}
```

## 🔄 **Cline 호환성**

### **완전 호환성 제공**

| Caret Mode     | Cline Mode  | 설명           |
| -------------- | ----------- | -------------- |
| **💬 Chatbot** | **📋 Plan** | 대화/계획 중심 |
| **🤖 Agent**   | **⚡ Act**  | 실행/작업 중심 |

### **매끄러운 전환**

- **기존 사용자**: 아무런 변경 없이 Plan/Act 모드 계속 사용
- **새로운 사용자**: 직관적인 Chatbot/Agent 모드 활용
- **혼합 사용**: 언제든지 Caret ↔ Cline 모드 전환 가능

## 📊 **현재 구현 현황**

### **✅ 완료된 핵심 기능**

| 컴포넌트 | 구현 상태 | 설명 |
|----------|-----------|------|
| **모드 관리** | ✅ 완료 | CaretModeManager (globalState 기반) |
| **도구 제한** | ✅ 완료 | isToolAllowed 메서드로 안전 제어 |
| **프롬프트** | ✅ 완료 | CaretPromptWrapper 독립 생성 |
| **gRPC 통신** | ✅ 완료 | SetCaretMode/GetCaretMode 서비스 |
| **UI 동기화** | ✅ 완료 | ExtensionStateContext localStorage |
| **Cline 보존** | ✅ 완료 | 기존 워크플로우 100% 유지 |

### **🎯 사용 방법**

#### **모드 전환**
1. **단축키**: `⌘⇧A` (macOS) 또는 `Ctrl+Shift+A` (Windows/Linux)
2. **UI 토글**: 채팅 입력창 상단의 모드 토글 버튼
3. **설정**: Caret ↔ Cline 시스템 전환

#### **Chatbot 모드 활용**
- "이 함수의 성능 문제점을 분석해줘"
- "코드 스타일 관점에서 리뷰해줘"
- "이 아키텍처의 장단점을 설명해줘"

#### **Agent 모드 활용**
- "사용자 인증 시스템을 JWT로 구현해줘"
- "이 버그를 찾아서 수정하고 테스트까지 완료해줘"
- "프로젝트를 Next.js로 설정하고 초기 구조 생성해줘"

## 🏗️ **기술적 특징**

### **1. 단일 경로 통합**
- **globalState**: 모든 상태를 VS Code globalState로 통합
- **중복 제거**: localStorage와 globalState 동기화로 일관성 확보
- **최소 수정**: 3개 파일만 변경으로 Cline 안정성 보장

### **2. 완전한 분리**
- **독립 디렉토리**: caret-src에서 모든 Caret 로직 관리
- **분기 최소화**: system-prompt/index.ts에서 단일 분기점
- **후진 호환**: 기존 Cline 사용자 워크플로우 100% 보존

---

## 🔗 **관련 문서**

- **[f06-json-system-prompt.mdx](./f06-json-system-prompt.mdx)**: 기술 인프라 레이어
- **[caret-architecture-and-implementation-guide.mdx](../development/caret-architecture-and-implementation-guide.mdx)**: 전체 아키텍처 가이드
# Cline-latest vs. Roo-Code 아키텍처 비교 분석 및 Caret 전환 전략

- **작성일**: 2025-09-06
- **작성자**: Alpha
- **목적**: Cline-latest와 독립적으로 발전한 Roo-Code의 아키텍처를 비교 분석하여, Caret이 Cline의 빠른 업데이트에 효과적으로 대응하고 장기적인 유지보수성을 확보하기 위한 최적의 아키텍처 전환 전략을 수립한다.

## 개요 (Overview)

Caret은 오픈소스 프로젝트 Cline을 기반으로 독자적인 기능을 추가하는 방식으로 개발되고 있습니다. 최근 Cline 프로젝트는 매우 빠른 속도로 발전하고 있으며, 수많은 기여자에 의해 핵심 기능과 구조가 빈번하게 변경되고 있습니다.

이러한 상황은 Caret에게 큰 기회이자 도전 과제입니다. Cline의 최신 기능을 빠르게 흡수할 수 있는 장점이 있지만, 우리가 수정한 코드와 원본의 차이가 커지면서 버전 업데이트 시 발생하는 병합 충돌(Merge Conflict)의 해결 비용이 기하급수적으로 증가하고 있습니다.

따라서 Caret은 **'최소 침습(Minimal Invasion)'** 및 **'소스 분리(Source Separation)'**를 핵심 전략으로 채택하여, Cline 원본 코드의 수정을 최소화하면서 안정적으로 기능을 확장할 수 있는 아키텍처를 모색하고 있습니다.

본 보고서는 과거 Cline에서 분기하여 독자적으로 발전한 Roo-Code의 사례를 분석하여, Caret이 현재의 고민을 해결하고 지속 가능한 개발 전략을 수립하는 데 필요한 통찰과 구체적인 실행 방안을 제시하는 것을 목적으로 합니다.

## 1. 요약 (Executive Summary)

Roo-Code는 Cline의 단일 구조(Monolith)에서 벗어나, 코드 재사용성과 확장성을 극대화하는 현대적인 **모노레포(Monorepo) 아키텍처**로 근본적인 전환을 이루었다.

핵심 전략은 **"Cline 원본의 라이브러리화"**로, Cline의 `src`를 직접 수정하기보다 필요한 기능을 외부 패키지(`packages/`)에서 독립적으로 개발하고, 진입점(`src/extension.ts`)에서는 이들을 **'조립(Orchestration)'**하는 역할만 수행한다.

Caret이 Cline의 빠른 업데이트에 효과적으로 대응하기 위해, Roo-Code의 **'지휘자(Orchestrator)' 패턴**을 도입하는 것을 강력히 권장한다. 이는 Cline 원본 파일의 수정을 최소화하여 향후 **병합(Merge) 과정을 반자동화**할 수 있는 기반을 마련하는 가장 현실적이고 강력한 전략이다.

## 2. 상세 비교 분석

| 분석 항목 | Cline-latest (원본) | Roo-Code (독립 발전) | Caret에 주는 시사점 |
| :--- | :--- | :--- | :--- |
| **프로젝트 구조** | **단일 구조 (Monolith)**<br/>- 모든 소스가 루트에 존재<br/>- 단순하지만, 수정 시 충돌 가능성 높음 | **모노레포 (Monorepo)**<br/>- `apps/`, `packages/`로 분리<br/>- 코드 재사용 및 분리 용이, 장기적 확장성 우수 | Caret의 `caret-src` 분리 전략이 올바른 방향임을 재확인. Roo-Code는 이를 더 체계화한 모습. |
| **`src` 디렉토리 역할** | **"핵심부 (Core)"**<br/>- 모든 핵심 기능과 로직이 위치 | **"진입점 (Entrypoint)"**<br/>- 확장 프로그램 실행과 조립 역할만 수행<br/>- 실제 기능은 `packages/`에 위임 | Caret도 Cline의 `src`를 '진입점'으로 취급하고, 모든 기능 개발은 `caret-src`에 집중하여 원본 수정을 최소화해야 함. |
| **`extension.ts` 역할** | **"실행자 (Executor)"**<br/>- 모든 기능을 직접 생성하고 등록<br/>- 파일이 길고 복잡하며, 병합 충돌의 주된 원인 | **"지휘자 (Orchestrator)"**<br/>- 외부 패키지의 서비스를 가져와 연결<br/>- 간결하고 역할이 명확, 수정 범위가 매우 작음 | **가장 중요한 부분.** Caret의 기능 추가 시, `extension.ts`에는 `caret-src`의 초기화 함수를 호출하는 단 한 줄만 추가하는 것을 목표로 해야 함. |

## 3. 아키텍처 전환의 장점

Roo-Code의 아키텍처를 채택함으로써 Caret은 다음과 같은 장점을 얻을 수 있다.

1.  **유지보수 비용 극적 감소**: Cline 원본 코드와 Caret의 코드가 명확히 분리되어, Cline 업데이트 시 병합 충돌이 발생할 지점이 최소화된다. 이는 수동 병합에 드는 시간과 노력을 획기적으로 줄여준다.
2.  **반자동화된 업데이트**: `src` 디렉토리를 거의 '읽기 전용'으로 취급할 수 있게 되어, Cline의 새 버전이 나오면 `src`를 통째로 교체하고 최소한의 연결 코드만 재적용하는 반자동화된 업데이트 프로세스가 가능해진다.
3.  **기능 개발 가속화**: Caret의 기능이 독립적인 서비스로 개발되므로, Cline의 내부 구조에 대한 의존성이 낮아진다. 개발자들은 Cline의 복잡한 전체 구조를 이해하지 않고도 `caret-src` 내에서 빠르게 기능을 개발하고 테스트할 수 있다.
4.  **미래 확장성 확보**: 웹 버전, 다른 IDE 지원 등 프로젝트 확장을 고려할 때, 핵심 로직이 분리되어 있어 다른 플랫폼으로의 이식이 용이하다.

## 4. 단계별 전환 방법 제안 (로드맵)

**핵심 원칙**: 이 전환의 목표는 **Cline의 소스 코드를 재구조화(Restructuring)하는 것이 아니라, Caret의 독자적인 기능을 Cline으로부터 분리(Decoupling)하고 독립적으로 모듈화하는 것**입니다. Cline 소스는 최대한 '원본 그대로'를 유지하며, 우리는 그 옆에 독립적인 '별채'를 짓고 최소한의 통로로 연결하는 것을 지향합니다.

### 1단계: 단기 실행 과제 (Immediate Action) - "발자국 최소화"

- **목표**: Cline 원본 파일(`extension.ts`)에 대한 수정 '발자국'을 최소화한다.
- **실행 방안**:
    1.  `caret-src/services/` 디렉토리 내에 `initializer.ts` 파일을 생성한다.
    2.  `initializeCaret(context)` 함수를 만들어, 현재 `extension.ts`에 추가된 Caret 관련 기능(커맨드 등록, 프로바이더 초기화 등)의 로직을 모두 이 함수로 이전한다.
    3.  Cline의 `extension.ts` 파일 `activate` 함수 최상단에는 `initializeCaret(context);` 단 한 줄만 남긴다.

### 2단계: 중기 목표 (Mid-term Goal) - "핵심 로직 완전 분리"

- **목표**: Caret이 수정하는 모든 Cline 원본 파일에서 Caret만의 로직을 `caret-src`로 이전하여, Cline `src`를 '읽기 전용' 상태로 만든다.
- **실행 방안**:
    1.  Caret이 수정한 모든 Cline `src` 내 파일 목록을 작성한다.
    2.  각 파일의 수정 사항을 분석하여, 해당 로직을 `caret-src` 내의 신규 서비스나 유틸리티로 재구현한다.
    3.  원본 파일은 최소한의 '연결고리(hook)'만 남기고 원래 로직으로 복원하거나, 불가피한 경우 래퍼(wrapper) 클래스 패턴을 사용한다.

### 3단계: 장기 비전 (Long-term Vision) - "업데이트 프로세스 자동화"

- **목표**: Cline-latest 버전 업데이트를 위한 스크립트를 작성하여 병합 과정을 자동화한다.
- **실행 방안**:
    1.  `cline-latest`의 특정 버전을 가져오는 스크립트를 작성한다.
    2.  스크립트가 기존 `src` 디렉토리를 백업 후 삭제하고, 새 버전의 `src`로 교체하도록 한다.
    3.  1단계에서 최소화된 '연결 코드'를 자동으로 다시 삽입하도록 한다.
    4.  `npm run compile` 및 `npm run test`를 실행하여 빌드 및 통합 테스트를 자동으로 수행하고 결과를 리포트한다.

## 5. 특별 분석: Roo-Code의 다국어(i18n) 전략

Cline 기반 프로젝트에서 기능 추가 시 가장 큰 난관 중 하나는 웹뷰(Webview) 전반에 걸쳐 필요한 다국어 처리입니다. Roo-Code가 이 문제를 어떻게 해결했는지 분석한 결과, '최소 침습' 원칙을 보여주는 매우 영리한 전략을 발견했습니다.

### 핵심 전략: 번역 파일의 웹뷰 내장 (Embedding)

Roo-Code는 백엔드가 번역 파일을 웹뷰에 '전달'하는 방식이 아니라, **웹뷰를 빌드할 때 모든 언어의 번역 파일을 JavaScript 코드 안에 미리 포함**시키는 방식을 사용합니다.

1.  **Vite 번들러 활용**: 웹뷰 빌드 도구인 Vite의 `import.meta.glob` 기능을 사용하여, 빌드 시점에 모든 번역 JSON 파일을 읽어와 웹뷰의 JavaScript 번들에 직접 포함시킵니다.
2.  **웹뷰의 독립성**: 이로 인해, 최종 생성된 웹뷰는 번역에 필요한 모든 언어 데이터를 스스로 가지게 됩니다. 백엔드에 번역 데이터를 요청할 필요가 전혀 없습니다.
3.  **최소한의 통신**: 백엔드는 웹뷰가 시작될 때, VS Code의 현재 언어 설정(`vscode.env.language`)이 무엇인지만 간단한 메시지로 알려줍니다. 웹뷰는 이 신호를 받아, 이미 내장된 데이터 중에서 해당 언어로 즉시 전환합니다.

이 방식은 웹뷰의 초기 로딩 파일 크기가 약간 커지는 단점이 있지만, 텍스트 데이터의 용량은 미미하여 현대적인 웹 환경에서는 거의 문제가 되지 않으며, 얻는 장점이 훨씬 큽니다.

### Caret을 위한 시사점

이 전략은 **백엔드와 프론트엔드를 완벽하게 분리(Decoupling)**하여 '최소 침습' 원칙을 극대화합니다. Caret이 이 방식을 도입한다면, Cline의 웹뷰 관련 코드를 거의 수정할 필요 없이, 언어 설정 신호를 보내는 메시지 핸들러 하나만 추가하여 정교한 다국어 시스템을 구축할 수 있습니다.

### Cline 기반 프로젝트에 i18n 시스템 구현 방법 (3단계)

만약 Cline의 웹뷰에 문자열이 하드코딩되어 있다면, 아래의 3단계 리팩토링을 통해 Roo-Code와 같은 시스템을 구현할 수 있습니다.

**1단계: 웹뷰에 i18n 라이브러리 설치 및 설정**
1.  `webview-ui`에 `i18next`, `react-i18next` 라이브러리를 설치합니다.
2.  `webview-ui/src/i18n/setup.ts` 파일을 만들어 `i18next`를 초기화하고, Vite의 `import.meta.glob`을 사용해 번역 파일을 불러오도록 설정합니다.
3.  React 앱 전체를 `TranslationContext`로 감싸 모든 컴포넌트에서 번역 함수(`t`)를 사용할 수 있도록 합니다.

**2단계: 문자열 외부화**
1.  `webview-ui/src/i18n/locales/en/common.json`과 같은 번역 파일을 생성합니다.
2.  웹뷰 컴포넌트(`*.tsx`)에 하드코딩된 문자열(예: `"Settings"`)을 번역 함수 호출(예: `t('common:settings')`)로 모두 교체합니다.
3.  JSON 파일에 해당 키와 값을 추가합니다. (예: `{"settings": "Settings"}`)

**3단계: 백엔드와 언어 설정 연동**
1.  Cline의 `WebviewProvider` 파일에서, 웹뷰가 준비되었을 때 VS Code의 현재 언어(`vscode.env.language`)를 메시지로 보내는 코드를 한 줄 추가합니다.
2.  웹뷰의 `App.tsx`에서 이 메시지를 수신하고, `i18next.changeLanguage(언어코드)`를 호출하여 언어를 동적으로 변경합니다.

# f05 - 규칙 우선순위 시스템 머징 작업
 * caret-compare 프로젝트에 이미 구현 되어있으므로 해당 프로젝트 참고
    => 우리 프로젝트의 구현방식으로 구현되어있는지는 대신 꼭 검증 필요


## 기능 개요
- **목적**: 토큰 낭비 방지 및 설정 충돌 해결을 위한 규칙 파일 우선순위 시스템
- **현재 상태**: ✅ 완전 구현 완료 (Phase 2-2에서 완성)
- **우선순위**: HIGH - 토큰 효율성 및 설정 관리 핵심

## 주요 구성 요소

### 우선순위 시스템
```
.caretrules > .clinerules > .cursorrules > .windsurfrules
```

### 핵심 기능
- **단일 선택**: 우선순위가 높은 규칙 파일이 존재하면 나머지는 무시
- **중복 방지**: 동일한 규칙이 여러 번 로딩되는 것을 완전 차단
- **토큰 절약**: 불필요한 중복 내용으로 인한 토큰 사용량 절약 (67% 감소)

### 수정된 핵심 파일 구조
```
백엔드 우선순위 로직:
src/core/context/instructions/user-instructions/
├── external-rules.ts              # 핵심 우선순위 로직 (CARET MODIFICATION)
├── rule-helpers.ts                # 규칙 동기화 헬퍼 함수들
└── cline-rules.ts                 # Cline 전용 규칙 처리

시스템 프롬프트 통합:
src/core/task/
└── index.ts                       # 우선순위 시스템 통합 (CARET MODIFICATION)

백엔드 제어 로직:
src/core/controller/file/
└── refreshRules.ts                # UI 데이터 전송 (CARET MODIFICATION)

Caret 백엔드 분리 로직:
caret-src/core/controller/file/
└── toggleCaretRule.ts             # .caretrules 토글 기능 (NEW)

파일 시스템 정의:
src/core/storage/
├── disk.ts                        # .caretrules 파일명 정의 (CARET MODIFICATION)
├── state-keys.ts                  # 상태 키 정의 (CARET MODIFICATION)
└── utils/state-helpers.ts         # 상태 초기화 (CARET MODIFICATION)

프로토콜 정의:
proto/cline/
└── file.proto                     # gRPC 통신 프로토콜 (CARET MODIFICATION)

UI 컴포넌트:
webview-ui/src/components/cline-rules/
└── ClineRulesToggleModal.tsx      # 규칙 토글 UI (CARET MODIFICATION)

UI 상태 관리:
webview-ui/src/context/
└── ExtensionStateContext.tsx      # 전역 상태 관리 (CARET MODIFICATION)
```

## 차별화 포인트
- **토큰 효율성**: 기존 300 토큰 → 100 토큰 (67% 절약)
- **충돌 방지**: 여러 규칙 파일 간 충돌 완전 제거
- **명확성**: 어떤 규칙이 적용되는지 명확히 파악 가능

## 머징 계획

### Phase 1: TDD 테스트 환경 구축
- [ ] 기존 단위 테스트 이식
  ```bash
  cp caret-main/src/test/rule-priority.test.ts src/test/
  cp caret-main/src/test/rule-priority-integration.test.ts src/test/
  ```
- [ ] 테스트 실행 확인
  ```bash
  npm run test:unit -- --testPathPattern=rule-priority
  ```

### Phase 2: 백엔드 우선순위 로직 이식
- [ ] 핵심 로직 파일 이식
  ```bash
  cp caret-main/src/core/context/instructions/user-instructions/external-rules.ts \
     src/core/context/instructions/user-instructions/
  ```
- [ ] toggleCaretRule 기능 이식
  ```bash
  cp caret-main/caret-src/core/controller/file/toggleCaretRule.ts \
     caret-src/core/controller/file/
  ```
- [ ] 시스템 프롬프트 통합
  ```bash
  # task/index.ts에 activeRuleInstructions 변수 로직 추가
  ```

### Phase 3: 파일 시스템 설정 이식
- [ ] 저장소 파일 수정
  ```bash
  # src/core/storage/disk.ts에 caretRules: ".caretrules" 추가
  # src/core/storage/state-keys.ts에 localCaretRulesToggles 키 추가
  # src/core/storage/utils/state-helpers.ts에 초기화 추가
  ```

### Phase 4: UI 통합
- [ ] UI 컴포넌트 업데이트
  ```typescript
  // ClineRulesToggleModal.tsx에 caretRules 목록 표시 추가
  // ExtensionStateContext.tsx에 localCaretRulesToggles 상태 관리 추가
  ```
- [ ] 프로토콜 정의 추가
  ```bash
  # proto/cline/file.proto에 local_caret_rules_toggles 필드 추가
  ```

### Phase 5: 통합 테스트
- [ ] 단위 테스트 (8개 테스트 케이스)
- [ ] 통합 테스트 (6개 파일 시스템 시나리오)
- [ ] 컴파일 성공 확인
- [ ] Proto 빌드 확인
- [ ] UI 통합 확인

## 핵심 로직 구현

### external-rules.ts - 우선순위 구현
```typescript
// CARET MODIFICATION: Implement rule priority system (.caretrules > .clinerules > .cursorrules > .windsurfrules)

// Step 3: Apply priority logic - disable lower priority rules if higher priority exists
const caretHasFiles = Object.keys(updatedLocalCaretToggles).length > 0
const windsurfHasFiles = Object.keys(updatedLocalWindsurfToggles).length > 0
const cursorHasFiles = Object.keys(updatedLocalCursorToggles).length > 0

if (caretHasFiles) {
    // .caretrules has highest priority - disable all others
    updatedLocalWindsurfToggles = disableAllToggles(updatedLocalWindsurfToggles)
    updatedLocalCursorToggles = disableAllToggles(updatedLocalCursorToggles)
} else if (windsurfHasFiles) {
    // .windsurfrules has second priority - disable cursor
    updatedLocalCursorToggles = disableAllToggles(updatedLocalCursorToggles)
}
// If only cursor rules exist, they remain enabled

function disableAllToggles(toggles: ClineRulesToggles): ClineRulesToggles {
    const disabledToggles: ClineRulesToggles = {}
    for (const filePath in toggles) {
        disabledToggles[filePath] = false
    }
    return disabledToggles
}
```

### task/index.ts - 프롬프트 통합
```typescript
// CARET MODIFICATION: Rule priority system (.caretrules > .clinerules > .cursorrules > .windsurfrules)
const localCaretRulesFileInstructions = await getLocalCaretRules(this.cwd, caretLocalToggles)
const localClineRulesFileInstructions = await getLocalClineRules(this.cwd, localToggles)

// Apply priority system: Use the highest priority rule that exists and is enabled
let activeRuleInstructions: string | undefined
if (localCaretRulesFileInstructions) {
    activeRuleInstructions = localCaretRulesFileInstructions
} else if (localClineRulesFileInstructions) {
    activeRuleInstructions = localClineRulesFileInstructions
} else if (localCursorRulesFileInstructions) {
    activeRuleInstructions = localCursorRulesFileInstructions
} else if (localWindsurfRulesFileInstructions) {
    activeRuleInstructions = localWindsurfRulesFileInstructions
}

// CARET MODIFICATION: Use priority system - only pass the active rule instead of all rules
const userInstructions = addUserInstructions(
    globalClineRulesFileInstructions,
    activeRuleInstructions, // Only the highest priority active rule
    undefined, // Other rules handled by priority system
    // ...
)
```

## 테스트 아키텍처

### 테스트 커버리지: ✅ 완전 통합 테스트

#### 단위 테스트: `src/test/rule-priority.test.ts`
- 대상: `addUserInstructions` 함수의 우선순위 로직
- 테스트 케이스: 8개 시나리오 (모든 우선순위 조합)

#### 통합 테스트: `src/test/rule-priority-integration.test.ts`
- 대상: 실제 파일 시스템과 `refreshExternalRulesToggles` 함수
- 테스트 케이스: 6개 시나리오 (실제 파일 생성/삭제)

### 통합 테스트 시나리오
1. 다중 규칙 파일 우선순위
2. 중간 우선순위 테스트
3. 단일 규칙 파일
4. 빈 디렉토리
5. 동적 파일 추가
6. 파일 삭제

## 주의사항 및 체크리스트

### 머징 시 주의사항
- [ ] 백업 필수: 원본 파일 수정 전 `.backup` 또는 `.cline` 백업 생성
- [ ] 마커 확인: `// CARET MODIFICATION:` 주석으로 수정 부분 명확히 표시
- [ ] 테스트 우선: 기능 이식 전 테스트 코드부터 이식
- [ ] 로그 확인: 규칙 로딩 과정이 로그에 올바르게 기록되는지 확인

### 완료 기준
- [ ] 단위 테스트: 8개 테스트 케이스 모두 통과
- [ ] 통합 테스트: 6개 파일 시스템 시나리오 통과
- [ ] 컴파일 성공: TypeScript 타입 검사 통과
- [ ] Proto 빌드: gRPC 통신 프로토콜 정상 생성
- [ ] UI 통합: Rules Toggle Modal에 .caretrules 표시
- [ ] 우선순위 로직: 파일 존재 시 낮은 우선순위 비활성화
- [ ] CARET MODIFICATION: 모든 수정 부분 주석 표시

## 호환성 및 마이그레이션

### 기존 사용자 호환성
- Cline 사용자: 기존 `.clinerules` 파일 그대로 사용 가능
- Cursor 사용자: 기존 `.cursorrules` 파일 그대로 사용 가능  
- Windsurf 사용자: 기존 `.windsurfrules` 파일 그대로 사용 가능

### 마이그레이션 가이드
1. 기존 규칙 확인
2. 우선 규칙 선택 (`.caretrules`로 복사 또는 이름 변경)
3. 중복 제거

## 성능 및 효과

### 토큰 사용량 절약
- Before: 3개 규칙 파일 × 평균 100 토큰 = 300 토큰
- After: 1개 규칙 파일 × 100 토큰 = 100 토큰
- 절약 효과: **67% 토큰 사용량 감소**

### 설정 관리 개선
- 충돌 제거: 여러 규칙 파일 간 충돌 완전 방지
- 명확성: 어떤 규칙이 적용되는지 명확히 파악 가능
- 유지보수: 단일 규칙 파일 관리로 복잡성 감소

## 향후 개선 계획

### 단기 계획
- UI 개선: Rules Toggle Modal에서 우선순위 로직 반영
- 안내 메시지: 비활성화된 규칙에 대한 사용자 안내
- 로깅 강화: 어떤 규칙 파일이 선택되었는지 명확한 로그

### 중기 계획
- 규칙 편집기: VSCode 내장 규칙 파일 편집 UI
- 템플릿 시스템: 프로젝트 유형별 규칙 템플릿 제공
- 상속 시스템: 글로벌/프로젝트 규칙 계층 구조

## 예상 소요 시간
- **총 시간**: 6-8시간
- **복잡도**: HIGH
- **위험도**: MEDIUM (외부 종속성)
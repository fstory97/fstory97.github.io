---
title: "ディーププランニングコマンド"
sidebarTitle: "/deep-planning"
---

`/deep-planning` は Cline を細心な設計者に変身させ、コードベースを調査し、明確化のための質問をして、一行のコードも書く前に包括的な実装計画を作成します。

<Frame>
	<img
		src="https://storage.googleapis.com/cline_public_images/docs/assets/deep-planning.png"
		alt="調査と計画プロセスを示すDeep Planningコマンドの実行画面"
	/>
</Frame>

`/deep-planning` を使用すると、Cline はシニアデベロッパーが複雑な機能にアプローチする方法を反映した4段階のプロセスに従います：徹底的な調査、要件の議論と明確化、詳細な計画、進捗追跡機能付きの構造化されたタスク作成。

## 4段階プロセス

### ステップ1：サイレント調査

Cline は探偵のようになり、静かにコードベースを探索してその構造、パターン、制約を理解します。ソースファイルを調べ、インポートパターンを分析し、クラス階層を発見し、技術的負債のマーカーを特定します。解説も実況もなし - ただ集中した調査のみです。

この段階で、Cline は次のようなコマンドを実行します：
- コードベース全体のすべてのクラスと関数定義を検索
- 依存関係を理解するためのインポートパターンの分析
- プロジェクト構造とファイル組織の発見
- TODOと技術的負債の特定

### ステップ2：議論と質問

Cline がコードベースを理解すると、実装を形作るターゲット質問をします。これらは一般的な質問ではありません - プロジェクトと構築中の機能に特化したものです。

質問の内容：
- 曖昧な要件の明確化
- 等価な実装アプローチ間での選択
- システムの動作に関する仮定の確認
- 技術的決定の好みの理解

### ステップ3：実装計画ドキュメント

Cline は実装の青写真となる構造化されたMarkdownドキュメント（`implementation_plan.md`）を作成します。これは曖昧な概要ではありません - 正確なファイルパス、関数シグネチャ、実装順序を含む詳細な仕様書です。

計画には8つの包括的なセクションが含まれます：
- **概要**: 目標と高レベルなアプローチ
- **型**: 完全な型定義とデータ構造
- **ファイル**: 作成、変更、削除する正確なファイル
- **関数**: シグネチャ付きの新規および変更された関数
- **クラス**: クラスの変更と継承の詳細
- **依存関係**: パッケージ要件とバージョン
- **テスト**: 検証戦略とテスト要件
- **実装順序**: ステップバイステップの実行シーケンス

### ステップ4：実装タスクの作成

Cline は計画ドキュメントを参照し、追跡可能な実装ステップを含む新しいタスクを作成します。このタスクには計画の各セクションを読むための具体的なコマンドが付属し、実装エージェント（あなたでも Act Mode の Cline でも）が効率的に青写真をナビゲートできるようにします。

<Tip>
  Deep Planning は [Focus Chain](/features/focus-chain) と美しく連携します。実装ステップは自動的にリアルタイムの進捗追跡付きのTODOリストになり、複雑なプロジェクトを整理された状態で軌道に乗せます。
</Tip>

## Deep Planning の使用方法

機能の説明に続けて `/deep-planning` と入力してディーププランニングセッションを開始します：

```
/deep-planning JWTトークンとロールベースのアクセス制御を持つユーザー認証を追加
```

Cline は直ちに調査を開始します。コードベースを理解するためにファイルを読み、コマンドを実行している様子が見えます。十分なコンテキストを収集すると、計画を作成する前にあなたと議論を始めます。

## ワークフローの例

実際の機能で `/deep-planning` をどう使うかの例：

<Steps>
  <Step title="計画の開始">
    `/deep-planning APIレスポンス用のキャッシュ層を実装` と入力
  </Step>
  <Step title="サイレント調査">
    Cline がコードベースを探索し、以下を調査：
    - 現在のAPI構造とエンドポイント
    - 既存のデータフローパターン
    - データベースクエリとパフォーマンスのボトルネック
    - 設定と環境セットアップ
  </Step>
  <Step title="ターゲット議論">
    Cline からの質問：
    - "Redisまたはインメモリキャッシュを使用すべきですか？"
    - "ユーザーデータにとって許容可能なキャッシュの古さはどれくらいですか？"
    - "キャッシュ無効化Webhookが必要ですか？"
  </Step>
  <Step title="計画作成">
    Cline が `implementation_plan.md` を生成：
    - キャッシュサービスクラスの仕様
    - Redis接続設定
    - キャッシングロジック付きの変更されたAPIエンドポイント
    - キャッシュキー生成戦略
    - 異なるデータタイプのTTL設定
  </Step>
  <Step title="タスク生成">
    Cline が新しいタスクを作成：
    - 実装計画への参照
    - 特定のセクションを読むコマンド
    - 各実装ステップの追跡可能なTODOアイテム
    - Act Mode への切り替えリクエスト
  </Step>
</Steps>

## Plan/Act Mode との統合

Deep Planning は [Plan/Act Mode](/features/plan-and-act) とシームレスに連携するよう設計されています：

- 調査と計画フェーズでは Plan Mode で `/deep-planning` を使用
- 生成されたタスクは実装のために Act Mode への切り替えを要求
- Focus Chain は実装ステップを通じて自動的に進捗を追跡

この分離により、計画はアーキテクチャに集中し、実装は実行に集中できます。

## ベストプラクティス

### Deep Planning をいつ使うか

次の場合に `/deep-planning` を使用してください：
- コードベースの複数の部分に触れる機能
- 慎重な調整が必要なアーキテクチャの変更
- 外部サービスとの複雑な統合
- 体系的な実行が必要なリファクタリング作業
- 通常ホワイトボードに時間を費やすような機能

### 調査を最大限活用する

Cline に調査を徹底的に完了させてください。計画の品質は、彼がコードベースをどれだけよく理解しているかに直接関連しています。調べてほしい特定の領域がある場合は、初期リクエストで言及してください。

### 計画のレビュー

実装を開始する前に必ず `implementation_plan.md` をレビューしてください。計画は包括的ですが不変ではありません - 必要に応じて直接編集できます。あなたと Cline の間の協力的なドキュメントと考えてください。

### 進捗の追跡

Focus Chain が有効の場合、実装の進捗がタスクヘッダーに表示されます。Cline が計画を進めると各完了ステップが自動的にチェックされ、複雑な実装にリアルタイムの可視性を提供します。

## インスピレーション

通常設計ドキュメントが必要な何かを構築しようとするときは常に `/deep-planning` を使用します。私のワークフローからの最近の例：

- **認証システムの移行**: Deep Planning がすべてのエンドポイントをマッピングし、すべての認証タッチポイントを特定し、破壊的変更を回避する移行計画を作成しました。

- **リアルタイム機能の追加**: 計画には WebSocket 統合、イベント処理、状態同期、切断時のフォールバック機構が含まれていました。

- **データベーススキーマのリファクタリング**: Cline が影響を受けるすべてのクエリを特定し、移行スクリプトを作成し、ダウンタイムを最小化するロールアウトを計画しました。

- **APIバージョニングの実装**: 計画にはルート変更、後方互換性レイヤー、廃止予定通知、クライアント移行パスが詳述されていました。

`/deep-planning` の力は、実装前に思慮深いアーキテクチャを強制することです。コードを書く前にシニアデベロッパーがアプローチをレビューしてもらうようなものですが、そのデベロッパーはあなたのコードベース全体を完璧に知っているのです。

<Note>
  Deep Planning には強力な推論能力を持つモデルが必要です。GPT-5、Claude 4、Gemini 2.5、Grok 4 などの最新世代のモデルで最も効果を発揮します。小さなモデルでは必要な包括的分析に苦戦する可能性があります。
</Note>

広範囲な計画を必要としない単純なタスクの場合は、[/newtask](/features/slash-commands/new-task) を使用してコンテキスト付きの集中タスクを作成するか、進む道が明確な場合は直接実装に進むことを検討してください。
